package proto

import (
	context "context"
	fmt "fmt"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	gorm "gorm.io/gorm"
	proto "model/proto"
	strings "strings"
)

type CompanyORM struct {
	Description *string
	Id          int32
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (CompanyORM) TableName() string {
	return "companies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Company) ToORM(ctx context.Context) (CompanyORM, error) {
	to := CompanyORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	// Repeated type Tag is not an ORMable message type
	if posthook, ok := interface{}(m).(CompanyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyORM) ToPB(ctx context.Context) (Company, error) {
	to := Company{}
	var err error
	if prehook, ok := interface{}(m).(CompanyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	// Repeated type Tag is not an ORMable message type
	if posthook, ok := interface{}(m).(CompanyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Company the arg will be the target, the caller the one being converted from

// CompanyBeforeToORM called before default ToORM code
type CompanyWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyORM) error
}

// CompanyAfterToORM called after default ToORM code
type CompanyWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyORM) error
}

// CompanyBeforeToPB called before default ToPB code
type CompanyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Company) error
}

// CompanyAfterToPB called after default ToPB code
type CompanyWithAfterToPB interface {
	AfterToPB(context.Context, *Company) error
}

type PrinterModelORM struct {
	Description             *string
	Id                      int32
	Name                    string
	PrinterModelFdmDataId   *int32
	PrinterModelOtherDataId *int32
	PrinterModelSlaDataId   *int32
	Type                    int32
}

// TableName overrides the default tablename generated by GORM
func (PrinterModelORM) TableName() string {
	return "printer_models"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PrinterModel) ToORM(ctx context.Context) (PrinterModelORM, error) {
	to := PrinterModelORM{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Type = int32(m.Type)
	if posthook, ok := interface{}(m).(PrinterModelWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PrinterModelORM) ToPB(ctx context.Context) (PrinterModel, error) {
	to := PrinterModel{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Type = proto.PrinterModelType(m.Type)
	if posthook, ok := interface{}(m).(PrinterModelWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PrinterModel the arg will be the target, the caller the one being converted from

// PrinterModelBeforeToORM called before default ToORM code
type PrinterModelWithBeforeToORM interface {
	BeforeToORM(context.Context, *PrinterModelORM) error
}

// PrinterModelAfterToORM called after default ToORM code
type PrinterModelWithAfterToORM interface {
	AfterToORM(context.Context, *PrinterModelORM) error
}

// PrinterModelBeforeToPB called before default ToPB code
type PrinterModelWithBeforeToPB interface {
	BeforeToPB(context.Context, *PrinterModel) error
}

// PrinterModelAfterToPB called after default ToPB code
type PrinterModelWithAfterToPB interface {
	AfterToPB(context.Context, *PrinterModel) error
}

type PrinterModelOtherDataORM struct {
	Depth        *float32
	Height       *float32
	Id           int32
	Metric       int32
	Power        *int32
	PrinterModel *PrinterModelORM `gorm:"foreignKey:PrinterModelOtherDataId;references:Id"`
	Weight       *float32
	Width        *float32
}

// TableName overrides the default tablename generated by GORM
func (PrinterModelOtherDataORM) TableName() string {
	return "printer_model_other_data"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PrinterModelOtherData) ToORM(ctx context.Context) (PrinterModelOtherDataORM, error) {
	to := PrinterModelOtherDataORM{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelOtherDataWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PrinterModel != nil {
		tempPrinterModel, err := m.PrinterModel.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PrinterModel = &tempPrinterModel
	}
	to.Metric = int32(m.Metric)
	to.Width = m.Width
	to.Height = m.Height
	to.Depth = m.Depth
	to.Weight = m.Weight
	to.Power = m.Power
	if posthook, ok := interface{}(m).(PrinterModelOtherDataWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PrinterModelOtherDataORM) ToPB(ctx context.Context) (PrinterModelOtherData, error) {
	to := PrinterModelOtherData{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelOtherDataWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PrinterModel != nil {
		tempPrinterModel, err := m.PrinterModel.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PrinterModel = &tempPrinterModel
	}
	to.Metric = proto.PrinterModelMetric(m.Metric)
	to.Width = m.Width
	to.Height = m.Height
	to.Depth = m.Depth
	to.Weight = m.Weight
	to.Power = m.Power
	if posthook, ok := interface{}(m).(PrinterModelOtherDataWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PrinterModelOtherData the arg will be the target, the caller the one being converted from

// PrinterModelOtherDataBeforeToORM called before default ToORM code
type PrinterModelOtherDataWithBeforeToORM interface {
	BeforeToORM(context.Context, *PrinterModelOtherDataORM) error
}

// PrinterModelOtherDataAfterToORM called after default ToORM code
type PrinterModelOtherDataWithAfterToORM interface {
	AfterToORM(context.Context, *PrinterModelOtherDataORM) error
}

// PrinterModelOtherDataBeforeToPB called before default ToPB code
type PrinterModelOtherDataWithBeforeToPB interface {
	BeforeToPB(context.Context, *PrinterModelOtherData) error
}

// PrinterModelOtherDataAfterToPB called after default ToPB code
type PrinterModelOtherDataWithAfterToPB interface {
	AfterToPB(context.Context, *PrinterModelOtherData) error
}

type PrinterModelFdmDataORM struct {
	BedCalibration        *int32
	Connectivities        []*PrinterModelConnectivityORM `gorm:"foreignKey:PrinterModelFdmDataId;references:Id"`
	Depth                 *float32
	FilamentMaterials     []*FilamentMaterialORM `gorm:"foreignKey:PrinterModelFdmDataId;references:Id"`
	HeatbedTemperatureMax *int32
	Height                *float32
	Id                    int32
	LayerHeightMax        *float32
	LayerHeightMin        *float32
	Metric                int32
	NozzleTemperatureMax  *int32
	Power                 *int32
	PrintDepth            *float32
	PrintHeight           *float32
	PrintSurfaces         []*FdmPrintSurfaceORM `gorm:"foreignKey:PrinterModelFdmDataId;references:Id"`
	PrintWidth            *float32
	PrinterModel          *PrinterModelORM `gorm:"foreignKey:PrinterModelFdmDataId;references:Id"`
	TemperatureScale      *int32
	Weight                *float32
	Width                 *float32
}

// TableName overrides the default tablename generated by GORM
func (PrinterModelFdmDataORM) TableName() string {
	return "printer_model_fdm_data"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PrinterModelFdmData) ToORM(ctx context.Context) (PrinterModelFdmDataORM, error) {
	to := PrinterModelFdmDataORM{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelFdmDataWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PrinterModel != nil {
		tempPrinterModel, err := m.PrinterModel.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PrinterModel = &tempPrinterModel
	}
	to.Metric = int32(m.Metric)
	to.Width = m.Width
	to.Height = m.Height
	to.Depth = m.Depth
	to.Weight = m.Weight
	to.Power = m.Power
	to.PrintWidth = m.PrintWidth
	to.PrintHeight = m.PrintHeight
	to.PrintDepth = m.PrintDepth
	to.LayerHeightMin = m.LayerHeightMin
	to.LayerHeightMax = m.LayerHeightMax
	to.TemperatureScale = int32(m.TemperatureScale)
	to.NozzleTemperatureMax = m.NozzleTemperatureMax
	to.HeatbedTemperatureMax = m.HeatbedTemperatureMax
	for _, v := range m.Connectivities {
		if v != nil {
			if tempConnectivities, cErr := v.ToORM(ctx); cErr == nil {
				to.Connectivities = append(to.Connectivities, &tempConnectivities)
			} else {
				return to, cErr
			}
		} else {
			to.Connectivities = append(to.Connectivities, nil)
		}
	}
	// Repeated type enum is not an ORMable message type
	for _, v := range m.PrintSurfaces {
		if v != nil {
			if tempPrintSurfaces, cErr := v.ToORM(ctx); cErr == nil {
				to.PrintSurfaces = append(to.PrintSurfaces, &tempPrintSurfaces)
			} else {
				return to, cErr
			}
		} else {
			to.PrintSurfaces = append(to.PrintSurfaces, nil)
		}
	}
	to.BedCalibration = int32(m.BedCalibration)
	for _, v := range m.FilamentMaterials {
		if v != nil {
			if tempFilamentMaterials, cErr := v.ToORM(ctx); cErr == nil {
				to.FilamentMaterials = append(to.FilamentMaterials, &tempFilamentMaterials)
			} else {
				return to, cErr
			}
		} else {
			to.FilamentMaterials = append(to.FilamentMaterials, nil)
		}
	}
	if posthook, ok := interface{}(m).(PrinterModelFdmDataWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PrinterModelFdmDataORM) ToPB(ctx context.Context) (PrinterModelFdmData, error) {
	to := PrinterModelFdmData{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelFdmDataWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PrinterModel != nil {
		tempPrinterModel, err := m.PrinterModel.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PrinterModel = &tempPrinterModel
	}
	to.Metric = proto.PrinterModelMetric(m.Metric)
	to.Width = m.Width
	to.Height = m.Height
	to.Depth = m.Depth
	to.Weight = m.Weight
	to.Power = m.Power
	to.PrintWidth = m.PrintWidth
	to.PrintHeight = m.PrintHeight
	to.PrintDepth = m.PrintDepth
	to.LayerHeightMin = m.LayerHeightMin
	to.LayerHeightMax = m.LayerHeightMax
	to.TemperatureScale = proto.TemperatureScale(m.TemperatureScale)
	to.NozzleTemperatureMax = m.NozzleTemperatureMax
	to.HeatbedTemperatureMax = m.HeatbedTemperatureMax
	for _, v := range m.Connectivities {
		if v != nil {
			if tempConnectivities, cErr := v.ToPB(ctx); cErr == nil {
				to.Connectivities = append(to.Connectivities, &tempConnectivities)
			} else {
				return to, cErr
			}
		} else {
			to.Connectivities = append(to.Connectivities, nil)
		}
	}
	// Repeated type enum is not an ORMable message type
	for _, v := range m.PrintSurfaces {
		if v != nil {
			if tempPrintSurfaces, cErr := v.ToPB(ctx); cErr == nil {
				to.PrintSurfaces = append(to.PrintSurfaces, &tempPrintSurfaces)
			} else {
				return to, cErr
			}
		} else {
			to.PrintSurfaces = append(to.PrintSurfaces, nil)
		}
	}
	to.BedCalibration = proto.Calibration(m.BedCalibration)
	for _, v := range m.FilamentMaterials {
		if v != nil {
			if tempFilamentMaterials, cErr := v.ToPB(ctx); cErr == nil {
				to.FilamentMaterials = append(to.FilamentMaterials, &tempFilamentMaterials)
			} else {
				return to, cErr
			}
		} else {
			to.FilamentMaterials = append(to.FilamentMaterials, nil)
		}
	}
	if posthook, ok := interface{}(m).(PrinterModelFdmDataWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PrinterModelFdmData the arg will be the target, the caller the one being converted from

// PrinterModelFdmDataBeforeToORM called before default ToORM code
type PrinterModelFdmDataWithBeforeToORM interface {
	BeforeToORM(context.Context, *PrinterModelFdmDataORM) error
}

// PrinterModelFdmDataAfterToORM called after default ToORM code
type PrinterModelFdmDataWithAfterToORM interface {
	AfterToORM(context.Context, *PrinterModelFdmDataORM) error
}

// PrinterModelFdmDataBeforeToPB called before default ToPB code
type PrinterModelFdmDataWithBeforeToPB interface {
	BeforeToPB(context.Context, *PrinterModelFdmData) error
}

// PrinterModelFdmDataAfterToPB called after default ToPB code
type PrinterModelFdmDataWithAfterToPB interface {
	AfterToPB(context.Context, *PrinterModelFdmData) error
}

type PrinterModelSlaDataORM struct {
	CalibrationZ         *int32
	Connectivities       []*PrinterModelConnectivityORM `gorm:"foreignKey:PrinterModelSlaDataId;references:Id"`
	Depth                *float32
	Height               *float32
	Id                   int32
	LayerThicknessMax    *float32
	LayerThicknessMin    *float32
	Metric               int32
	Power                *int32
	PrintDepth           *float32
	PrintHeight          *float32
	PrintSpeedPerHourMax *int32
	PrintWidth           *float32
	PrinterModel         *PrinterModelORM `gorm:"foreignKey:PrinterModelSlaDataId;references:Id"`
	ResolutionX          *float32
	ResolutionY          *float32
	Storage              *int32
	Weight               *float32
	Width                *float32
}

// TableName overrides the default tablename generated by GORM
func (PrinterModelSlaDataORM) TableName() string {
	return "printer_model_sla_data"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PrinterModelSlaData) ToORM(ctx context.Context) (PrinterModelSlaDataORM, error) {
	to := PrinterModelSlaDataORM{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelSlaDataWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PrinterModel != nil {
		tempPrinterModel, err := m.PrinterModel.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PrinterModel = &tempPrinterModel
	}
	to.Metric = int32(m.Metric)
	to.Width = m.Width
	to.Height = m.Height
	to.Depth = m.Depth
	to.Weight = m.Weight
	to.Power = m.Power
	to.PrintWidth = m.PrintWidth
	to.PrintHeight = m.PrintHeight
	to.PrintDepth = m.PrintDepth
	to.LayerThicknessMin = m.LayerThicknessMin
	to.LayerThicknessMax = m.LayerThicknessMax
	to.ResolutionX = m.ResolutionX
	to.ResolutionY = m.ResolutionY
	to.PrintSpeedPerHourMax = m.PrintSpeedPerHourMax
	to.Storage = m.Storage
	for _, v := range m.Connectivities {
		if v != nil {
			if tempConnectivities, cErr := v.ToORM(ctx); cErr == nil {
				to.Connectivities = append(to.Connectivities, &tempConnectivities)
			} else {
				return to, cErr
			}
		} else {
			to.Connectivities = append(to.Connectivities, nil)
		}
	}
	// Repeated type enum is not an ORMable message type
	to.CalibrationZ = int32(m.CalibrationZ)
	if posthook, ok := interface{}(m).(PrinterModelSlaDataWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PrinterModelSlaDataORM) ToPB(ctx context.Context) (PrinterModelSlaData, error) {
	to := PrinterModelSlaData{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelSlaDataWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PrinterModel != nil {
		tempPrinterModel, err := m.PrinterModel.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PrinterModel = &tempPrinterModel
	}
	to.Metric = proto.PrinterModelMetric(m.Metric)
	to.Width = m.Width
	to.Height = m.Height
	to.Depth = m.Depth
	to.Weight = m.Weight
	to.Power = m.Power
	to.PrintWidth = m.PrintWidth
	to.PrintHeight = m.PrintHeight
	to.PrintDepth = m.PrintDepth
	to.LayerThicknessMin = m.LayerThicknessMin
	to.LayerThicknessMax = m.LayerThicknessMax
	to.ResolutionX = m.ResolutionX
	to.ResolutionY = m.ResolutionY
	to.PrintSpeedPerHourMax = m.PrintSpeedPerHourMax
	to.Storage = m.Storage
	for _, v := range m.Connectivities {
		if v != nil {
			if tempConnectivities, cErr := v.ToPB(ctx); cErr == nil {
				to.Connectivities = append(to.Connectivities, &tempConnectivities)
			} else {
				return to, cErr
			}
		} else {
			to.Connectivities = append(to.Connectivities, nil)
		}
	}
	// Repeated type enum is not an ORMable message type
	to.CalibrationZ = proto.Calibration(m.CalibrationZ)
	if posthook, ok := interface{}(m).(PrinterModelSlaDataWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PrinterModelSlaData the arg will be the target, the caller the one being converted from

// PrinterModelSlaDataBeforeToORM called before default ToORM code
type PrinterModelSlaDataWithBeforeToORM interface {
	BeforeToORM(context.Context, *PrinterModelSlaDataORM) error
}

// PrinterModelSlaDataAfterToORM called after default ToORM code
type PrinterModelSlaDataWithAfterToORM interface {
	AfterToORM(context.Context, *PrinterModelSlaDataORM) error
}

// PrinterModelSlaDataBeforeToPB called before default ToPB code
type PrinterModelSlaDataWithBeforeToPB interface {
	BeforeToPB(context.Context, *PrinterModelSlaData) error
}

// PrinterModelSlaDataAfterToPB called after default ToPB code
type PrinterModelSlaDataWithAfterToPB interface {
	AfterToPB(context.Context, *PrinterModelSlaData) error
}

type FilamentDiameterORM struct {
	Id     int32
	Metric int32
	Value  float32
}

// TableName overrides the default tablename generated by GORM
func (FilamentDiameterORM) TableName() string {
	return "filament_diameters"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FilamentDiameter) ToORM(ctx context.Context) (FilamentDiameterORM, error) {
	to := FilamentDiameterORM{}
	var err error
	if prehook, ok := interface{}(m).(FilamentDiameterWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Value = m.Value
	to.Metric = int32(m.Metric)
	if posthook, ok := interface{}(m).(FilamentDiameterWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FilamentDiameterORM) ToPB(ctx context.Context) (FilamentDiameter, error) {
	to := FilamentDiameter{}
	var err error
	if prehook, ok := interface{}(m).(FilamentDiameterWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Value = m.Value
	to.Metric = proto.PrinterModelMetric(m.Metric)
	if posthook, ok := interface{}(m).(FilamentDiameterWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FilamentDiameter the arg will be the target, the caller the one being converted from

// FilamentDiameterBeforeToORM called before default ToORM code
type FilamentDiameterWithBeforeToORM interface {
	BeforeToORM(context.Context, *FilamentDiameterORM) error
}

// FilamentDiameterAfterToORM called after default ToORM code
type FilamentDiameterWithAfterToORM interface {
	AfterToORM(context.Context, *FilamentDiameterORM) error
}

// FilamentDiameterBeforeToPB called before default ToPB code
type FilamentDiameterWithBeforeToPB interface {
	BeforeToPB(context.Context, *FilamentDiameter) error
}

// FilamentDiameterAfterToPB called after default ToPB code
type FilamentDiameterWithAfterToPB interface {
	AfterToPB(context.Context, *FilamentDiameter) error
}

type FilamentMaterialORM struct {
	Description           *string
	Id                    int32
	Name                  string
	PrinterModelFdmDataId *int32
}

// TableName overrides the default tablename generated by GORM
func (FilamentMaterialORM) TableName() string {
	return "filament_materials"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FilamentMaterial) ToORM(ctx context.Context) (FilamentMaterialORM, error) {
	to := FilamentMaterialORM{}
	var err error
	if prehook, ok := interface{}(m).(FilamentMaterialWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(FilamentMaterialWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FilamentMaterialORM) ToPB(ctx context.Context) (FilamentMaterial, error) {
	to := FilamentMaterial{}
	var err error
	if prehook, ok := interface{}(m).(FilamentMaterialWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(FilamentMaterialWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FilamentMaterial the arg will be the target, the caller the one being converted from

// FilamentMaterialBeforeToORM called before default ToORM code
type FilamentMaterialWithBeforeToORM interface {
	BeforeToORM(context.Context, *FilamentMaterialORM) error
}

// FilamentMaterialAfterToORM called after default ToORM code
type FilamentMaterialWithAfterToORM interface {
	AfterToORM(context.Context, *FilamentMaterialORM) error
}

// FilamentMaterialBeforeToPB called before default ToPB code
type FilamentMaterialWithBeforeToPB interface {
	BeforeToPB(context.Context, *FilamentMaterial) error
}

// FilamentMaterialAfterToPB called after default ToPB code
type FilamentMaterialWithAfterToPB interface {
	AfterToPB(context.Context, *FilamentMaterial) error
}

type FdmPrintSurfaceORM struct {
	Id                    int32
	Name                  string
	PrinterModelFdmDataId *int32
}

// TableName overrides the default tablename generated by GORM
func (FdmPrintSurfaceORM) TableName() string {
	return "fdm_print_surfaces"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FdmPrintSurface) ToORM(ctx context.Context) (FdmPrintSurfaceORM, error) {
	to := FdmPrintSurfaceORM{}
	var err error
	if prehook, ok := interface{}(m).(FdmPrintSurfaceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if posthook, ok := interface{}(m).(FdmPrintSurfaceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FdmPrintSurfaceORM) ToPB(ctx context.Context) (FdmPrintSurface, error) {
	to := FdmPrintSurface{}
	var err error
	if prehook, ok := interface{}(m).(FdmPrintSurfaceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if posthook, ok := interface{}(m).(FdmPrintSurfaceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FdmPrintSurface the arg will be the target, the caller the one being converted from

// FdmPrintSurfaceBeforeToORM called before default ToORM code
type FdmPrintSurfaceWithBeforeToORM interface {
	BeforeToORM(context.Context, *FdmPrintSurfaceORM) error
}

// FdmPrintSurfaceAfterToORM called after default ToORM code
type FdmPrintSurfaceWithAfterToORM interface {
	AfterToORM(context.Context, *FdmPrintSurfaceORM) error
}

// FdmPrintSurfaceBeforeToPB called before default ToPB code
type FdmPrintSurfaceWithBeforeToPB interface {
	BeforeToPB(context.Context, *FdmPrintSurface) error
}

// FdmPrintSurfaceAfterToPB called after default ToPB code
type FdmPrintSurfaceWithAfterToPB interface {
	AfterToPB(context.Context, *FdmPrintSurface) error
}

type PrinterModelConnectivityORM struct {
	Id                    int32
	Name                  string
	PrinterModelFdmDataId *int32
	PrinterModelSlaDataId *int32
	Type                  int32
}

// TableName overrides the default tablename generated by GORM
func (PrinterModelConnectivityORM) TableName() string {
	return "printer_model_connectivities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PrinterModelConnectivity) ToORM(ctx context.Context) (PrinterModelConnectivityORM, error) {
	to := PrinterModelConnectivityORM{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelConnectivityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Type = int32(m.Type)
	if posthook, ok := interface{}(m).(PrinterModelConnectivityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PrinterModelConnectivityORM) ToPB(ctx context.Context) (PrinterModelConnectivity, error) {
	to := PrinterModelConnectivity{}
	var err error
	if prehook, ok := interface{}(m).(PrinterModelConnectivityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Type = proto.PrinterModelConnectivityType(m.Type)
	if posthook, ok := interface{}(m).(PrinterModelConnectivityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PrinterModelConnectivity the arg will be the target, the caller the one being converted from

// PrinterModelConnectivityBeforeToORM called before default ToORM code
type PrinterModelConnectivityWithBeforeToORM interface {
	BeforeToORM(context.Context, *PrinterModelConnectivityORM) error
}

// PrinterModelConnectivityAfterToORM called after default ToORM code
type PrinterModelConnectivityWithAfterToORM interface {
	AfterToORM(context.Context, *PrinterModelConnectivityORM) error
}

// PrinterModelConnectivityBeforeToPB called before default ToPB code
type PrinterModelConnectivityWithBeforeToPB interface {
	BeforeToPB(context.Context, *PrinterModelConnectivity) error
}

// PrinterModelConnectivityAfterToPB called after default ToPB code
type PrinterModelConnectivityWithAfterToPB interface {
	AfterToPB(context.Context, *PrinterModelConnectivity) error
}

// DefaultCreateCompany executes a basic gorm create call
func DefaultCreateCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompany(ctx context.Context, in *Company, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanySet(ctx context.Context, in []*Company, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CompanyORM{})).(CompanyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyORM{})).(CompanyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Company, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Company, *gorm.DB) error
}

// DefaultStrictUpdateCompany clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompany(ctx context.Context, in *Company, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompany")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompany executes a basic gorm update call with patch behavior
func DefaultPatchCompany(ctx context.Context, in *Company, updateMask *field_mask.FieldMask, db *gorm.DB) (*Company, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Company
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCompany(ctx, &Company{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompany(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompany(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Company, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompany executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompany(ctx context.Context, objects []*Company, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Company, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Company, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompany(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompany patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompany(ctx context.Context, patchee *Company, patcher *Company, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Company, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompany executes a gorm list call
func DefaultListCompany(ctx context.Context, db *gorm.DB) ([]*Company, error) {
	in := Company{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CompanyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Company{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyORM) error
}

// DefaultCreatePrinterModel executes a basic gorm create call
func DefaultCreatePrinterModel(ctx context.Context, in *PrinterModel, db *gorm.DB) (*PrinterModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPrinterModel(ctx context.Context, in *PrinterModel, db *gorm.DB) (*PrinterModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PrinterModelORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PrinterModelORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModel(ctx context.Context, in *PrinterModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PrinterModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PrinterModelORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelSet(ctx context.Context, in []*PrinterModel, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PrinterModelORM{})).(PrinterModelORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PrinterModelORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PrinterModelORM{})).(PrinterModelORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PrinterModelORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PrinterModel, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PrinterModel, *gorm.DB) error
}

// DefaultStrictUpdatePrinterModel clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePrinterModel(ctx context.Context, in *PrinterModel, db *gorm.DB) (*PrinterModel, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePrinterModel")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PrinterModelORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PrinterModelORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPrinterModel executes a basic gorm update call with patch behavior
func DefaultPatchPrinterModel(ctx context.Context, in *PrinterModel, updateMask *field_mask.FieldMask, db *gorm.DB) (*PrinterModel, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PrinterModel
	var err error
	if hook, ok := interface{}(&pbObj).(PrinterModelWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPrinterModel(ctx, &PrinterModel{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PrinterModelWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPrinterModel(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PrinterModelWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePrinterModel(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PrinterModelWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PrinterModelWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PrinterModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PrinterModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PrinterModel, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PrinterModel, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPrinterModel executes a bulk gorm update call with patch behavior
func DefaultPatchSetPrinterModel(ctx context.Context, objects []*PrinterModel, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PrinterModel, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PrinterModel, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPrinterModel(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPrinterModel patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPrinterModel(ctx context.Context, patchee *PrinterModel, patcher *PrinterModel, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PrinterModel, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPrinterModel executes a gorm list call
func DefaultListPrinterModel(ctx context.Context, db *gorm.DB) ([]*PrinterModel, error) {
	in := PrinterModel{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PrinterModelORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PrinterModel{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PrinterModelORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PrinterModelORM) error
}

// DefaultCreatePrinterModelOtherData executes a basic gorm create call
func DefaultCreatePrinterModelOtherData(ctx context.Context, in *PrinterModelOtherData, db *gorm.DB) (*PrinterModelOtherData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelOtherDataORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPrinterModelOtherData(ctx context.Context, in *PrinterModelOtherData, db *gorm.DB) (*PrinterModelOtherData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PrinterModelOtherDataORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PrinterModelOtherDataORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelOtherDataORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelOtherData(ctx context.Context, in *PrinterModelOtherData, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PrinterModelOtherDataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PrinterModelOtherDataORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelOtherDataSet(ctx context.Context, in []*PrinterModelOtherData, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PrinterModelOtherDataORM{})).(PrinterModelOtherDataORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PrinterModelOtherDataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PrinterModelOtherDataORM{})).(PrinterModelOtherDataORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PrinterModelOtherDataORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PrinterModelOtherData, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PrinterModelOtherData, *gorm.DB) error
}

// DefaultStrictUpdatePrinterModelOtherData clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePrinterModelOtherData(ctx context.Context, in *PrinterModelOtherData, db *gorm.DB) (*PrinterModelOtherData, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePrinterModelOtherData")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PrinterModelOtherDataORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterPrinterModel := PrinterModelORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPrinterModel.PrinterModelOtherDataId = new(int32)
	*filterPrinterModel.PrinterModelOtherDataId = ormObj.Id
	if err = db.Where(filterPrinterModel).Delete(PrinterModelORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PrinterModelOtherDataORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPrinterModelOtherData executes a basic gorm update call with patch behavior
func DefaultPatchPrinterModelOtherData(ctx context.Context, in *PrinterModelOtherData, updateMask *field_mask.FieldMask, db *gorm.DB) (*PrinterModelOtherData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PrinterModelOtherData
	var err error
	if hook, ok := interface{}(&pbObj).(PrinterModelOtherDataWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPrinterModelOtherData(ctx, &PrinterModelOtherData{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PrinterModelOtherDataWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPrinterModelOtherData(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PrinterModelOtherDataWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePrinterModelOtherData(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PrinterModelOtherDataWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PrinterModelOtherDataWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PrinterModelOtherData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PrinterModelOtherData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PrinterModelOtherData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PrinterModelOtherData, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPrinterModelOtherData executes a bulk gorm update call with patch behavior
func DefaultPatchSetPrinterModelOtherData(ctx context.Context, objects []*PrinterModelOtherData, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PrinterModelOtherData, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PrinterModelOtherData, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPrinterModelOtherData(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPrinterModelOtherData patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPrinterModelOtherData(ctx context.Context, patchee *PrinterModelOtherData, patcher *PrinterModelOtherData, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PrinterModelOtherData, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPrinterModel bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedPrinterModel && strings.HasPrefix(f, prefix+"PrinterModel.") {
			updatedPrinterModel = true
			if patcher.PrinterModel == nil {
				patchee.PrinterModel = nil
				continue
			}
			if patchee.PrinterModel == nil {
				patchee.PrinterModel = &proto.PrinterModel{}
			}
			if o, err := proto.DefaultApplyFieldMaskPrinterModel(ctx, patchee.PrinterModel, patcher.PrinterModel, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PrinterModel.", db); err != nil {
				return nil, err
			} else {
				patchee.PrinterModel = o
			}
			continue
		}
		if f == prefix+"PrinterModel" {
			updatedPrinterModel = true
			patchee.PrinterModel = patcher.PrinterModel
			continue
		}
		if f == prefix+"Metric" {
			patchee.Metric = patcher.Metric
			continue
		}
		if f == prefix+"Width" {
			patchee.Width = patcher.Width
			continue
		}
		if f == prefix+"Height" {
			patchee.Height = patcher.Height
			continue
		}
		if f == prefix+"Depth" {
			patchee.Depth = patcher.Depth
			continue
		}
		if f == prefix+"Weight" {
			patchee.Weight = patcher.Weight
			continue
		}
		if f == prefix+"Power" {
			patchee.Power = patcher.Power
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPrinterModelOtherData executes a gorm list call
func DefaultListPrinterModelOtherData(ctx context.Context, db *gorm.DB) ([]*PrinterModelOtherData, error) {
	in := PrinterModelOtherData{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PrinterModelOtherDataORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelOtherDataORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PrinterModelOtherData{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PrinterModelOtherDataORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelOtherDataORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PrinterModelOtherDataORM) error
}

// DefaultCreatePrinterModelFdmData executes a basic gorm create call
func DefaultCreatePrinterModelFdmData(ctx context.Context, in *PrinterModelFdmData, db *gorm.DB) (*PrinterModelFdmData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelFdmDataORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPrinterModelFdmData(ctx context.Context, in *PrinterModelFdmData, db *gorm.DB) (*PrinterModelFdmData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PrinterModelFdmDataORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PrinterModelFdmDataORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelFdmDataORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelFdmData(ctx context.Context, in *PrinterModelFdmData, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PrinterModelFdmDataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PrinterModelFdmDataORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelFdmDataSet(ctx context.Context, in []*PrinterModelFdmData, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PrinterModelFdmDataORM{})).(PrinterModelFdmDataORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PrinterModelFdmDataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PrinterModelFdmDataORM{})).(PrinterModelFdmDataORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PrinterModelFdmDataORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PrinterModelFdmData, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PrinterModelFdmData, *gorm.DB) error
}

// DefaultStrictUpdatePrinterModelFdmData clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePrinterModelFdmData(ctx context.Context, in *PrinterModelFdmData, db *gorm.DB) (*PrinterModelFdmData, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePrinterModelFdmData")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PrinterModelFdmDataORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterConnectivities := PrinterModelConnectivityORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterConnectivities.PrinterModelFdmDataId = new(int32)
	*filterConnectivities.PrinterModelFdmDataId = ormObj.Id
	if err = db.Where(filterConnectivities).Delete(PrinterModelConnectivityORM{}).Error; err != nil {
		return nil, err
	}
	filterFilamentMaterials := FilamentMaterialORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterFilamentMaterials.PrinterModelFdmDataId = new(int32)
	*filterFilamentMaterials.PrinterModelFdmDataId = ormObj.Id
	if err = db.Where(filterFilamentMaterials).Delete(FilamentMaterialORM{}).Error; err != nil {
		return nil, err
	}
	filterPrintSurfaces := FdmPrintSurfaceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPrintSurfaces.PrinterModelFdmDataId = new(int32)
	*filterPrintSurfaces.PrinterModelFdmDataId = ormObj.Id
	if err = db.Where(filterPrintSurfaces).Delete(FdmPrintSurfaceORM{}).Error; err != nil {
		return nil, err
	}
	filterPrinterModel := PrinterModelORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPrinterModel.PrinterModelFdmDataId = new(int32)
	*filterPrinterModel.PrinterModelFdmDataId = ormObj.Id
	if err = db.Where(filterPrinterModel).Delete(PrinterModelORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PrinterModelFdmDataORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPrinterModelFdmData executes a basic gorm update call with patch behavior
func DefaultPatchPrinterModelFdmData(ctx context.Context, in *PrinterModelFdmData, updateMask *field_mask.FieldMask, db *gorm.DB) (*PrinterModelFdmData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PrinterModelFdmData
	var err error
	if hook, ok := interface{}(&pbObj).(PrinterModelFdmDataWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPrinterModelFdmData(ctx, &PrinterModelFdmData{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PrinterModelFdmDataWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPrinterModelFdmData(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PrinterModelFdmDataWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePrinterModelFdmData(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PrinterModelFdmDataWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PrinterModelFdmDataWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PrinterModelFdmData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PrinterModelFdmData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PrinterModelFdmData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PrinterModelFdmData, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPrinterModelFdmData executes a bulk gorm update call with patch behavior
func DefaultPatchSetPrinterModelFdmData(ctx context.Context, objects []*PrinterModelFdmData, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PrinterModelFdmData, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PrinterModelFdmData, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPrinterModelFdmData(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPrinterModelFdmData patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPrinterModelFdmData(ctx context.Context, patchee *PrinterModelFdmData, patcher *PrinterModelFdmData, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PrinterModelFdmData, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPrinterModel bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedPrinterModel && strings.HasPrefix(f, prefix+"PrinterModel.") {
			updatedPrinterModel = true
			if patcher.PrinterModel == nil {
				patchee.PrinterModel = nil
				continue
			}
			if patchee.PrinterModel == nil {
				patchee.PrinterModel = &proto.PrinterModel{}
			}
			if o, err := proto.DefaultApplyFieldMaskPrinterModel(ctx, patchee.PrinterModel, patcher.PrinterModel, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PrinterModel.", db); err != nil {
				return nil, err
			} else {
				patchee.PrinterModel = o
			}
			continue
		}
		if f == prefix+"PrinterModel" {
			updatedPrinterModel = true
			patchee.PrinterModel = patcher.PrinterModel
			continue
		}
		if f == prefix+"Metric" {
			patchee.Metric = patcher.Metric
			continue
		}
		if f == prefix+"Width" {
			patchee.Width = patcher.Width
			continue
		}
		if f == prefix+"Height" {
			patchee.Height = patcher.Height
			continue
		}
		if f == prefix+"Depth" {
			patchee.Depth = patcher.Depth
			continue
		}
		if f == prefix+"Weight" {
			patchee.Weight = patcher.Weight
			continue
		}
		if f == prefix+"Power" {
			patchee.Power = patcher.Power
			continue
		}
		if f == prefix+"PrintWidth" {
			patchee.PrintWidth = patcher.PrintWidth
			continue
		}
		if f == prefix+"PrintHeight" {
			patchee.PrintHeight = patcher.PrintHeight
			continue
		}
		if f == prefix+"PrintDepth" {
			patchee.PrintDepth = patcher.PrintDepth
			continue
		}
		if f == prefix+"LayerHeightMin" {
			patchee.LayerHeightMin = patcher.LayerHeightMin
			continue
		}
		if f == prefix+"LayerHeightMax" {
			patchee.LayerHeightMax = patcher.LayerHeightMax
			continue
		}
		if f == prefix+"TemperatureScale" {
			patchee.TemperatureScale = patcher.TemperatureScale
			continue
		}
		if f == prefix+"NozzleTemperatureMax" {
			patchee.NozzleTemperatureMax = patcher.NozzleTemperatureMax
			continue
		}
		if f == prefix+"HeatbedTemperatureMax" {
			patchee.HeatbedTemperatureMax = patcher.HeatbedTemperatureMax
			continue
		}
		if f == prefix+"Connectivities" {
			patchee.Connectivities = patcher.Connectivities
			continue
		}
		if f == prefix+"PrintMediums" {
			patchee.PrintMediums = patcher.PrintMediums
			continue
		}
		if f == prefix+"PrintSurfaces" {
			patchee.PrintSurfaces = patcher.PrintSurfaces
			continue
		}
		if f == prefix+"BedCalibration" {
			patchee.BedCalibration = patcher.BedCalibration
			continue
		}
		if f == prefix+"FilamentMaterials" {
			patchee.FilamentMaterials = patcher.FilamentMaterials
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPrinterModelFdmData executes a gorm list call
func DefaultListPrinterModelFdmData(ctx context.Context, db *gorm.DB) ([]*PrinterModelFdmData, error) {
	in := PrinterModelFdmData{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PrinterModelFdmDataORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelFdmDataORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PrinterModelFdmData{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PrinterModelFdmDataORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelFdmDataORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PrinterModelFdmDataORM) error
}

// DefaultCreatePrinterModelSlaData executes a basic gorm create call
func DefaultCreatePrinterModelSlaData(ctx context.Context, in *PrinterModelSlaData, db *gorm.DB) (*PrinterModelSlaData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelSlaDataORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPrinterModelSlaData(ctx context.Context, in *PrinterModelSlaData, db *gorm.DB) (*PrinterModelSlaData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PrinterModelSlaDataORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PrinterModelSlaDataORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelSlaDataORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelSlaData(ctx context.Context, in *PrinterModelSlaData, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PrinterModelSlaDataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PrinterModelSlaDataORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelSlaDataSet(ctx context.Context, in []*PrinterModelSlaData, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PrinterModelSlaDataORM{})).(PrinterModelSlaDataORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PrinterModelSlaDataORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PrinterModelSlaDataORM{})).(PrinterModelSlaDataORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PrinterModelSlaDataORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PrinterModelSlaData, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PrinterModelSlaData, *gorm.DB) error
}

// DefaultStrictUpdatePrinterModelSlaData clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePrinterModelSlaData(ctx context.Context, in *PrinterModelSlaData, db *gorm.DB) (*PrinterModelSlaData, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePrinterModelSlaData")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PrinterModelSlaDataORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterConnectivities := PrinterModelConnectivityORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterConnectivities.PrinterModelSlaDataId = new(int32)
	*filterConnectivities.PrinterModelSlaDataId = ormObj.Id
	if err = db.Where(filterConnectivities).Delete(PrinterModelConnectivityORM{}).Error; err != nil {
		return nil, err
	}
	filterPrinterModel := PrinterModelORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPrinterModel.PrinterModelSlaDataId = new(int32)
	*filterPrinterModel.PrinterModelSlaDataId = ormObj.Id
	if err = db.Where(filterPrinterModel).Delete(PrinterModelORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PrinterModelSlaDataORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPrinterModelSlaData executes a basic gorm update call with patch behavior
func DefaultPatchPrinterModelSlaData(ctx context.Context, in *PrinterModelSlaData, updateMask *field_mask.FieldMask, db *gorm.DB) (*PrinterModelSlaData, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PrinterModelSlaData
	var err error
	if hook, ok := interface{}(&pbObj).(PrinterModelSlaDataWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPrinterModelSlaData(ctx, &PrinterModelSlaData{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PrinterModelSlaDataWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPrinterModelSlaData(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PrinterModelSlaDataWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePrinterModelSlaData(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PrinterModelSlaDataWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PrinterModelSlaDataWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PrinterModelSlaData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PrinterModelSlaData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PrinterModelSlaData, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PrinterModelSlaData, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPrinterModelSlaData executes a bulk gorm update call with patch behavior
func DefaultPatchSetPrinterModelSlaData(ctx context.Context, objects []*PrinterModelSlaData, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PrinterModelSlaData, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PrinterModelSlaData, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPrinterModelSlaData(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPrinterModelSlaData patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPrinterModelSlaData(ctx context.Context, patchee *PrinterModelSlaData, patcher *PrinterModelSlaData, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PrinterModelSlaData, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPrinterModel bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedPrinterModel && strings.HasPrefix(f, prefix+"PrinterModel.") {
			updatedPrinterModel = true
			if patcher.PrinterModel == nil {
				patchee.PrinterModel = nil
				continue
			}
			if patchee.PrinterModel == nil {
				patchee.PrinterModel = &proto.PrinterModel{}
			}
			if o, err := proto.DefaultApplyFieldMaskPrinterModel(ctx, patchee.PrinterModel, patcher.PrinterModel, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PrinterModel.", db); err != nil {
				return nil, err
			} else {
				patchee.PrinterModel = o
			}
			continue
		}
		if f == prefix+"PrinterModel" {
			updatedPrinterModel = true
			patchee.PrinterModel = patcher.PrinterModel
			continue
		}
		if f == prefix+"Metric" {
			patchee.Metric = patcher.Metric
			continue
		}
		if f == prefix+"Width" {
			patchee.Width = patcher.Width
			continue
		}
		if f == prefix+"Height" {
			patchee.Height = patcher.Height
			continue
		}
		if f == prefix+"Depth" {
			patchee.Depth = patcher.Depth
			continue
		}
		if f == prefix+"Weight" {
			patchee.Weight = patcher.Weight
			continue
		}
		if f == prefix+"Power" {
			patchee.Power = patcher.Power
			continue
		}
		if f == prefix+"PrintWidth" {
			patchee.PrintWidth = patcher.PrintWidth
			continue
		}
		if f == prefix+"PrintHeight" {
			patchee.PrintHeight = patcher.PrintHeight
			continue
		}
		if f == prefix+"PrintDepth" {
			patchee.PrintDepth = patcher.PrintDepth
			continue
		}
		if f == prefix+"LayerThicknessMin" {
			patchee.LayerThicknessMin = patcher.LayerThicknessMin
			continue
		}
		if f == prefix+"LayerThicknessMax" {
			patchee.LayerThicknessMax = patcher.LayerThicknessMax
			continue
		}
		if f == prefix+"ResolutionX" {
			patchee.ResolutionX = patcher.ResolutionX
			continue
		}
		if f == prefix+"ResolutionY" {
			patchee.ResolutionY = patcher.ResolutionY
			continue
		}
		if f == prefix+"PrintSpeedPerHourMax" {
			patchee.PrintSpeedPerHourMax = patcher.PrintSpeedPerHourMax
			continue
		}
		if f == prefix+"Storage" {
			patchee.Storage = patcher.Storage
			continue
		}
		if f == prefix+"Connectivities" {
			patchee.Connectivities = patcher.Connectivities
			continue
		}
		if f == prefix+"PrintMediums" {
			patchee.PrintMediums = patcher.PrintMediums
			continue
		}
		if f == prefix+"CalibrationZ" {
			patchee.CalibrationZ = patcher.CalibrationZ
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPrinterModelSlaData executes a gorm list call
func DefaultListPrinterModelSlaData(ctx context.Context, db *gorm.DB) ([]*PrinterModelSlaData, error) {
	in := PrinterModelSlaData{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PrinterModelSlaDataORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelSlaDataORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PrinterModelSlaData{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PrinterModelSlaDataORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelSlaDataORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PrinterModelSlaDataORM) error
}

// DefaultCreateFilamentDiameter executes a basic gorm create call
func DefaultCreateFilamentDiameter(ctx context.Context, in *FilamentDiameter, db *gorm.DB) (*FilamentDiameter, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FilamentDiameterORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFilamentDiameter(ctx context.Context, in *FilamentDiameter, db *gorm.DB) (*FilamentDiameter, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FilamentDiameterORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FilamentDiameterORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FilamentDiameterORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFilamentDiameter(ctx context.Context, in *FilamentDiameter, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FilamentDiameterORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FilamentDiameterORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFilamentDiameterSet(ctx context.Context, in []*FilamentDiameter, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FilamentDiameterORM{})).(FilamentDiameterORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FilamentDiameterORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FilamentDiameterORM{})).(FilamentDiameterORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FilamentDiameterORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FilamentDiameter, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FilamentDiameter, *gorm.DB) error
}

// DefaultStrictUpdateFilamentDiameter clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFilamentDiameter(ctx context.Context, in *FilamentDiameter, db *gorm.DB) (*FilamentDiameter, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFilamentDiameter")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FilamentDiameterORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FilamentDiameterORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFilamentDiameter executes a basic gorm update call with patch behavior
func DefaultPatchFilamentDiameter(ctx context.Context, in *FilamentDiameter, updateMask *field_mask.FieldMask, db *gorm.DB) (*FilamentDiameter, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FilamentDiameter
	var err error
	if hook, ok := interface{}(&pbObj).(FilamentDiameterWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFilamentDiameter(ctx, &FilamentDiameter{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FilamentDiameterWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFilamentDiameter(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FilamentDiameterWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFilamentDiameter(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FilamentDiameterWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FilamentDiameterWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FilamentDiameter, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FilamentDiameter, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FilamentDiameter, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FilamentDiameter, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFilamentDiameter executes a bulk gorm update call with patch behavior
func DefaultPatchSetFilamentDiameter(ctx context.Context, objects []*FilamentDiameter, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FilamentDiameter, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FilamentDiameter, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFilamentDiameter(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFilamentDiameter patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFilamentDiameter(ctx context.Context, patchee *FilamentDiameter, patcher *FilamentDiameter, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FilamentDiameter, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Value" {
			patchee.Value = patcher.Value
			continue
		}
		if f == prefix+"Metric" {
			patchee.Metric = patcher.Metric
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFilamentDiameter executes a gorm list call
func DefaultListFilamentDiameter(ctx context.Context, db *gorm.DB) ([]*FilamentDiameter, error) {
	in := FilamentDiameter{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FilamentDiameterORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentDiameterORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FilamentDiameter{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FilamentDiameterORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentDiameterORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FilamentDiameterORM) error
}

// DefaultCreateFilamentMaterial executes a basic gorm create call
func DefaultCreateFilamentMaterial(ctx context.Context, in *FilamentMaterial, db *gorm.DB) (*FilamentMaterial, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FilamentMaterialORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFilamentMaterial(ctx context.Context, in *FilamentMaterial, db *gorm.DB) (*FilamentMaterial, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FilamentMaterialORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FilamentMaterialORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FilamentMaterialORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFilamentMaterial(ctx context.Context, in *FilamentMaterial, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FilamentMaterialORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FilamentMaterialORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFilamentMaterialSet(ctx context.Context, in []*FilamentMaterial, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FilamentMaterialORM{})).(FilamentMaterialORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FilamentMaterialORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FilamentMaterialORM{})).(FilamentMaterialORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FilamentMaterialORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FilamentMaterial, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FilamentMaterial, *gorm.DB) error
}

// DefaultStrictUpdateFilamentMaterial clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFilamentMaterial(ctx context.Context, in *FilamentMaterial, db *gorm.DB) (*FilamentMaterial, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFilamentMaterial")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FilamentMaterialORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FilamentMaterialORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFilamentMaterial executes a basic gorm update call with patch behavior
func DefaultPatchFilamentMaterial(ctx context.Context, in *FilamentMaterial, updateMask *field_mask.FieldMask, db *gorm.DB) (*FilamentMaterial, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FilamentMaterial
	var err error
	if hook, ok := interface{}(&pbObj).(FilamentMaterialWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFilamentMaterial(ctx, &FilamentMaterial{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FilamentMaterialWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFilamentMaterial(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FilamentMaterialWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFilamentMaterial(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FilamentMaterialWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FilamentMaterialWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FilamentMaterial, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FilamentMaterial, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FilamentMaterial, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FilamentMaterial, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFilamentMaterial executes a bulk gorm update call with patch behavior
func DefaultPatchSetFilamentMaterial(ctx context.Context, objects []*FilamentMaterial, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FilamentMaterial, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FilamentMaterial, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFilamentMaterial(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFilamentMaterial patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFilamentMaterial(ctx context.Context, patchee *FilamentMaterial, patcher *FilamentMaterial, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FilamentMaterial, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFilamentMaterial executes a gorm list call
func DefaultListFilamentMaterial(ctx context.Context, db *gorm.DB) ([]*FilamentMaterial, error) {
	in := FilamentMaterial{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FilamentMaterialORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FilamentMaterialORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FilamentMaterial{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FilamentMaterialORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FilamentMaterialORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FilamentMaterialORM) error
}

// DefaultCreateFdmPrintSurface executes a basic gorm create call
func DefaultCreateFdmPrintSurface(ctx context.Context, in *FdmPrintSurface, db *gorm.DB) (*FdmPrintSurface, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FdmPrintSurfaceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFdmPrintSurface(ctx context.Context, in *FdmPrintSurface, db *gorm.DB) (*FdmPrintSurface, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FdmPrintSurfaceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FdmPrintSurfaceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FdmPrintSurfaceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFdmPrintSurface(ctx context.Context, in *FdmPrintSurface, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FdmPrintSurfaceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FdmPrintSurfaceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFdmPrintSurfaceSet(ctx context.Context, in []*FdmPrintSurface, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FdmPrintSurfaceORM{})).(FdmPrintSurfaceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FdmPrintSurfaceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FdmPrintSurfaceORM{})).(FdmPrintSurfaceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FdmPrintSurfaceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FdmPrintSurface, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FdmPrintSurface, *gorm.DB) error
}

// DefaultStrictUpdateFdmPrintSurface clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFdmPrintSurface(ctx context.Context, in *FdmPrintSurface, db *gorm.DB) (*FdmPrintSurface, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFdmPrintSurface")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FdmPrintSurfaceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FdmPrintSurfaceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFdmPrintSurface executes a basic gorm update call with patch behavior
func DefaultPatchFdmPrintSurface(ctx context.Context, in *FdmPrintSurface, updateMask *field_mask.FieldMask, db *gorm.DB) (*FdmPrintSurface, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FdmPrintSurface
	var err error
	if hook, ok := interface{}(&pbObj).(FdmPrintSurfaceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFdmPrintSurface(ctx, &FdmPrintSurface{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FdmPrintSurfaceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFdmPrintSurface(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FdmPrintSurfaceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFdmPrintSurface(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FdmPrintSurfaceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FdmPrintSurfaceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FdmPrintSurface, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FdmPrintSurface, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FdmPrintSurface, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FdmPrintSurface, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFdmPrintSurface executes a bulk gorm update call with patch behavior
func DefaultPatchSetFdmPrintSurface(ctx context.Context, objects []*FdmPrintSurface, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FdmPrintSurface, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FdmPrintSurface, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFdmPrintSurface(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFdmPrintSurface patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFdmPrintSurface(ctx context.Context, patchee *FdmPrintSurface, patcher *FdmPrintSurface, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FdmPrintSurface, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFdmPrintSurface executes a gorm list call
func DefaultListFdmPrintSurface(ctx context.Context, db *gorm.DB) ([]*FdmPrintSurface, error) {
	in := FdmPrintSurface{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FdmPrintSurfaceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FdmPrintSurfaceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FdmPrintSurface{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FdmPrintSurfaceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FdmPrintSurfaceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FdmPrintSurfaceORM) error
}

// DefaultCreatePrinterModelConnectivity executes a basic gorm create call
func DefaultCreatePrinterModelConnectivity(ctx context.Context, in *PrinterModelConnectivity, db *gorm.DB) (*PrinterModelConnectivity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelConnectivityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPrinterModelConnectivity(ctx context.Context, in *PrinterModelConnectivity, db *gorm.DB) (*PrinterModelConnectivity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PrinterModelConnectivityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PrinterModelConnectivityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PrinterModelConnectivityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelConnectivity(ctx context.Context, in *PrinterModelConnectivity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PrinterModelConnectivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PrinterModelConnectivityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePrinterModelConnectivitySet(ctx context.Context, in []*PrinterModelConnectivity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PrinterModelConnectivityORM{})).(PrinterModelConnectivityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PrinterModelConnectivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PrinterModelConnectivityORM{})).(PrinterModelConnectivityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PrinterModelConnectivityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PrinterModelConnectivity, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PrinterModelConnectivity, *gorm.DB) error
}

// DefaultStrictUpdatePrinterModelConnectivity clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePrinterModelConnectivity(ctx context.Context, in *PrinterModelConnectivity, db *gorm.DB) (*PrinterModelConnectivity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePrinterModelConnectivity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PrinterModelConnectivityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PrinterModelConnectivityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPrinterModelConnectivity executes a basic gorm update call with patch behavior
func DefaultPatchPrinterModelConnectivity(ctx context.Context, in *PrinterModelConnectivity, updateMask *field_mask.FieldMask, db *gorm.DB) (*PrinterModelConnectivity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PrinterModelConnectivity
	var err error
	if hook, ok := interface{}(&pbObj).(PrinterModelConnectivityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPrinterModelConnectivity(ctx, &PrinterModelConnectivity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PrinterModelConnectivityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPrinterModelConnectivity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PrinterModelConnectivityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePrinterModelConnectivity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PrinterModelConnectivityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PrinterModelConnectivityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PrinterModelConnectivity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PrinterModelConnectivity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PrinterModelConnectivity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PrinterModelConnectivity, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPrinterModelConnectivity executes a bulk gorm update call with patch behavior
func DefaultPatchSetPrinterModelConnectivity(ctx context.Context, objects []*PrinterModelConnectivity, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PrinterModelConnectivity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PrinterModelConnectivity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPrinterModelConnectivity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPrinterModelConnectivity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPrinterModelConnectivity(ctx context.Context, patchee *PrinterModelConnectivity, patcher *PrinterModelConnectivity, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PrinterModelConnectivity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPrinterModelConnectivity executes a gorm list call
func DefaultListPrinterModelConnectivity(ctx context.Context, db *gorm.DB) ([]*PrinterModelConnectivity, error) {
	in := PrinterModelConnectivity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PrinterModelConnectivityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrinterModelConnectivityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PrinterModelConnectivity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PrinterModelConnectivityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PrinterModelConnectivityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PrinterModelConnectivityORM) error
}
